  constructor(tagID, data, options = {}) {
    let width = options['width'];
    if (true == options['widthToPage']) {
      width = document.body.clientWidth - 10;
    }

    this.statusTag = document.getElementById('Status');
    this.divRoot = document.getElementById(tagID);
    this.divRoot.innerHTML = '';
    this.divRoot.style.width = width;

    this.panel = {
      width: width,
      height: options['heightPanel'],
      radius: Math.floor(options['heightPanel'] * 0.1),
      scrollBox: {
        width: Math.floor(width * 0.25),
        x: Math.floor(width * 0.2),
        h1: Math.floor(options['heightPanel'] * 0.03),
        w1: Math.min(Math.floor(width * 0.03), 30)
      }
    };

    this.svgRoot = TC20.createSVG('svg');
    TC20.setA(this.svgRoot, {height: options['height'] + 'px', width: width + 'px'});
    this.divRoot.append(this.svgRoot);

    this.svgPanel = TC20.createSVG('svg');
    TC20.setA(this.svgPanel, {height: options['heightPanel'] + 'px', width: width + 'px', 'style': `border-radius: ${this.panel.radius}px;`});

    this.divRoot.append(this.svgPanel);

    this.width = this.svgPanel.width.animVal.value;
    this.height = this.svgRoot.height.animVal.value;
    this.animationStack = new Set();
    this.semafors = {};
    this.prepareData(data);

    this.graph = {};
    for (let i of this.allItems) {
      this.graph[i] = TC20.path({'d': '', 'stroke-width': 2, 'stroke': this.data.raw.colors[i], 'fill': 'none'});
      this.svgRoot.append(this.graph[i]);
    }

    this.render();
    this.count = 0;
  }
